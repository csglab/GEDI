---
title: "Run GEDI"
output:
  html_notebook:
    df_print: paged
---

We will run GEDI on the pbmc data from https://doi.org/10.1038/s41587-020-0534-z

# Loading libraries

```{r, message=FALSE}

library(scran)
library(scater)
library(tictoc)
library(Matrix)
library(uwot)

source("gedi/scIntegration.v98.svdC.R") # load GEDI functions

```

# Loading data

```{r}

sce<- readRDS("sce.rds")
var_genes<- readRDS("variable_genes.rds")
sce$log10_sum<- log10(sce$sum) ## adding variable of log10(totalcounts)

raw_counts<- assay(sce, "counts")

table(sce$Sample)

```

Filtering out low expressed genes

```{r}

## Filtering low expressed genes ( at least 3 cells express more than 1 counts)        
sum_genes<- rowSums(raw_counts>5)
genes_use<- sum_genes>3
table(genes_use)

sce<- sce[genes_use,]

sce
    
```


## Subsetting data matrices to most variable genes. 


This step is optional, but it augments performance and reduces optimization time. 

```{r}

var_genes<- intersect(var_genes, rownames(sce) )
raw_counts<- raw_counts[var_genes,]

```

## Loading C matrix of prior information

```{r}

c_mat<- readRDS("C_matrices/CellMarker.rds")

```

Setting up C matrix

```{r}

commongenes<- intersect(rownames(c_mat), rownames(raw_counts) )
c_mat<- c_mat[commongenes,]
raw_counts<- raw_counts[commongenes,]

# remove any columns that results in singularity
QR <- qr(crossprod(c_mat))
c_mat <- c_mat[ , QR$pivot[seq_len(QR$rank)] ]
    
```

```{r}

dim(colData(sce))
dim(c_mat)
dim(raw_counts)

```

# Run GEDI

## Run model

Main arguments for running GEDI are: 

* Samples:  Batch variable to use. It should be a character vector.
* expression matrix: Could be one of the following:
	+ Y: The log-transformed (and possibly normalized) gene expression matrix.
	+ M: The raw read count matrix.  It can also be a list of two matrices, in which case they are considered as paired observations whose log-ratio must be modelled.
* K: The number of latent variables.
* mode: Two values are allowed: 
	+ Bl2: L2 norm of the entire B matrix is fixed. Interpretation is that we’re projecting the data on a lower-dimensional hyperplane with dimension K. 
	+ Bsphere: L2 norms of B columns are fixed. Interpretation is that we’re projecting the data on a hyperellipsoid of dimension K. 	
* itelim: Number of iterations for optimization.

Optional arguments:

* C: The gene-level biological prior. If NULL, it means that there is no prior for Z
* H: The gene-level prior for unwanted sources of variation. If NULL, there will be no prior for Qi 

For this run, we are going to use GEDI with the raw counts, Bsphere mode and a matrix of cell type markers ( from cellmarker database) as prior biological information.

```{r, eval=FALSE}

K<- 100
itelim <- 150
mode <- "Bsphere"
oi_shrinkage<- 0.001

model <- new("GEDI") # Initialize GEDI object
model$setup( Samples = sce$Sample, M = raw_counts, C=c_mat, mode = mode, K = K, oi_shrinkage=oi_shrinkage ) # set up parameters
model$initialize.LVs(randomSeed = 1) # initialize LVs
tic("Optimization")
model$optimize(itelim) # run model
toc()

```

We can also resume optimization if needed.

```{r, eval=FALSE}

itelim<- 350

tic("resuming optimization")
model$optimize(itelim)
toc()

```


Saving model 

```{r, eval=FALSE}

saveRDS(model, "model.rds")

```

Loading model

```{r}

model<- readRDS('model.rds')

```


## Convergence of GEDI

```{r}

model$plotTracking()

```


## Dimensional reduction

```{r, fig.width=8, fig.height=8}

# Return the SVD projection of the integrated data
# This function returns a K x N matrix, with K being the number of latent variables and N being the number of cells
model_svd<- model$svd.projection()

# umap
set.seed(43)
umap_obj <- umap( t(model_svd), a=7, b=0.8, min_dist=0.01, metric="euclidean")
colnames(umap_obj)<- paste0("umap", 1:2)
rownames(umap_obj)<- colnames(sce)
reducedDim(sce, "umap")<- umap_obj ## Adding umap coordinates to sce object

for(var_plot in c("Sample", "CellType", "log10_sum", "subsets_mito_percent") ){
    print( plot_dimred(sce, var_plot, size_dot=0.05) )
}

```

Measuring performance of integration

```{r}

alignment_score(t(umap_obj), data.frame(colData(sce)), var_use="Sample")

1- alignment_score(t(umap_obj), data.frame(colData(sce)), var_use="CellType")

```

We observe a high alignment score ( good batch correction) and good values for the cell type conservation. 

## Interpretation 


```{r}

A_lv<- model$getA()
A_cell<- model$getADB()

```

Visualizing activities per latent variable

```{r, fig.width=8, fig.height=12}

pheatmap.colorsymmetric(A_lv, fontsize_row=3, fontsize_col=5)                        

```

This heatmap associates each latent variable to a given gene set from our C matrix. So, we could identify the main lvs driving variability in our dataset. 

Other approach that is also helpful is to look at the activities per cell. Using these, we can find if any of our cell populations of interest show differential activity patterns. In this case, we will use the 'CellType' category, but we could use any label, e.g. derive clusters, etc. 

```{r}

sce_A<- SingleCellExperiment( list(logcounts=A_cell), colData=colData(sce))
# Doing a t test looking for upregulated markers for each population ( cell types in this case) 
markers_sce <- findMarkers(sce_A, group=colData(sce)[,"CellType"], test.type="t", pval.type="all", direction="up") 
lis_markers<- summary_markers(markers_sce)
markers_fdr<- do.call(cbind, lapply(lis_markers, function(X) X[,"neglog_FDR",drop=FALSE] ) )
colnames(markers_fdr)<- names(lis_markers)

markers_fdr

```

Plotting -log10 FDR values for association of activity per each celltype
Filtered heatmap with only rows with at least 1 significant association

```{r, fig.width=8, fig.height=12}

filt<- markers_fdr[apply(markers_fdr, 1, max) > -log10(0.05),]

pheatmap.colorsymmetric(filt)

```

Visualizing the highest association for each cell type

```{r, fig.width=8, fig.height=8}

colData(sce)<- cbind(colData(sce), t(A_cell)[colnames(sce),] )

for( celltype in colnames(markers_fdr) ){
    cat("Celltype:", celltype, "\n")
    sig_markers<- markers_fdr[markers_fdr[,celltype] > -log10(0.05),]
    sig_markers<- sig_markers[order(-sig_markers[,celltype]),]
    if( nrow(sig_markers) > 0 ){
        for ( var_look in head(rownames(sig_markers),1) ){
            print( plot_dimred(sce, var_look, size_dot=0.05, center=TRUE) )
            print(plotExpression(sce_A,
                                 features = var_look,
                                 x = "CellType",
                                 exprs_values = "logcounts",                         
                                 colour_by = "CellType",
                                 point_size = 0.1) +           
                  labs(title=celltype, y="activity" ) +
                  fun_theme_plot()
                  )
        }
    }
}

```

We observe relatively good annotation using this C matrix, with good predicted activities for Bcells, CD14+ monocytes, NK cells and Plasmacytoid dendritic cells. 


## Imputation 

Perform imputation given the raw counts. 

```{r, fig.width=8, fig.height=7}

# This function returns a J x N matrix, with J being the number of genes and N being the number of cells
# Residual of Yi after taking into account everything other than ZDBi
# The effect of sample-specific distortions and cell-specific library sizes is removed

imputedY<- model$imputeY()

sce_impute<- SingleCellExperiment(list(imputedY=imputedY), colData=colData(sce) )

vec_genes<- c( "IL7R")

for( gene_look in vec_genes) {
    print( plotExpression(sce,
                          features = gene_look,
                          x = "CellType",
                          exprs_values = "logcounts",                         
                          colour_by = "CellType",
                          point_size = 0.1)+
           fun_theme_plot()
          )
    print( plotExpression(sce_impute,
                          features = gene_look,
                          x = "CellType",
                          exprs_values = "imputedY",                         
                          colour_by = "CellType",
                          point_size = 1) +
           fun_theme_plot()
          )    
}

```


```{r}

sessionInfo()

```
