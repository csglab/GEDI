---
title: "process_data"
output:
  html_notebook:
    df_print: paged
---

## Loading libraries

```{r, message=FALSE}

library(scater)
library(scran)
library(batchelor)
library(ggrepel)
library(ggrastr)

```

## Functions

```{r}

#' Function to get variable genes per batch
#'  modelGeneVar from scran package asssumes that the variation in expression for most genes is driven by uninteresting processes like sampling noise. Under this assumption, the fitted value of the trend at any given gene’s abundance represents an estimate of its uninteresting variation, which we call the technical component. We then define the biological component for each gene as the difference between its total variance and the technical component. This biological component represents the “interesting” variation for each gene and can be used as the metric for HVG selection.
#' @param sce SCE object
#' @param batch_variable batch variable to use per batch
#' @param n_var_genes number of variable genes to use per each batch ( it could be less if there are not enough expressed genes )
#' @return matrix that indicates which genes are variable per batch
get_variablegenes_batch<- function(sce, batch_variable="Sample", n_var_genes=3000, mean_cutoff=-2){
    require(ggrepel)
    require(ggrastr)
    batch_vars<- unique(colData(sce)[,batch_variable])
    mat_variable<- matrix(nrow=nrow(sce), ncol=length(batch_vars) )
    rownames(mat_variable)<- rownames(sce)
    colnames(mat_variable)<- batch_vars
    for( batch_look in batch_vars ){
        sce_sample<- sce[, colData(sce)[,batch_variable] == batch_look ]
        ## Filtering low expressed genes ( at least 3 cells express more than 1 counts)
        raw_counts_sample<- assay(sce_sample, "counts")
        sum_genes<- rowSums( assay(sce_sample, "counts")>1)
        genes_use<- sum_genes>3
        sce_sample<- sce_sample[genes_use,]
        print(batch_look)
        print(table(genes_use))
        ## Modelling mean-variance relationship
        genevar <- modelGeneVar(sce_sample)
        genevar<- genevar[order(-genevar$bio),]
        ## ordering by high expressed genes preferentially ( if there are not enough, it will still take n_var_genes
        genevar$log2_mean<- log2(genevar$mean )
        genevar$mean_filtered<- genevar$log2_mean > mean_cutoff
        ## Plotting the genes taken as most variable
        genevar<- genevar[order(-genevar$mean_filtered, -genevar$bio),]
        genevar$most_variable<- c( rep(TRUE, n_var_genes), rep(FALSE, length((n_var_genes+1):nrow(genevar)) ) )
        genevar$label_gene<- c(rownames(genevar)[1:20], rep(NA, nrow(genevar)-20))
        ggp<- ggplot(data.frame(genevar), aes(log2_mean, total, color=most_variable, label=label_gene) ) +
            rasterise(geom_point(size=0.05), dpi = 72)+
            geom_text_repel()+
            labs(title=batch_look, y="total variance")
        print(ggp)
        mat_variable[,batch_look]<- rownames(sce) %in% rownames(genevar[genevar$most_variable == TRUE,])
    }
    return(mat_variable)        
}


```

## Reading data

```{r}

raw_counts<- readRDS('raw_counts_initial.rds')
meta<- readRDS('meta_initial.rds')

```


## Creating Single Cell Experiment object

```{r}

sce<- SingleCellExperiment(list(counts=raw_counts), colData=meta)

sce

colData(sce)

sce <- addPerCellQC(sce, subsets=list(mito=grep("MT-", rownames(sce) ) ) )

colData(sce)

```

Normalization

```{r}

table(colData(sce)$Method)

## Creating a 'sample' column with batch information
colData(sce)$Sample<- colData(sce)$Method

sce<- multiBatchNorm(sce, batch=colData(sce)$Sample) 

sce

```

Obtaining most variable genes per batch

```{r}

mat_variable<- get_variablegenes_batch(sce)

head(mat_variable)


```

Variable genes for all

```{r}

vec_count<- rowSums(mat_variable)

variable_genes<- names(which(vec_count>2)) ## Variable genes present in at least 2 batches

length(variable_genes) 

```

## Saving objects

```{r}

saveRDS(sce, "sce.rds")
saveRDS(variable_genes, "variable_genes.rds")

```

```{r}

sessionInfo()

```
